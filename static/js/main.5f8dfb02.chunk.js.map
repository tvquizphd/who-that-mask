{"version":3,"sources":["containers/Output.module.css","containers/OutputLine.js","containers/OutputChar.js","containers/Output.js","containers/App.js","index.js"],"names":["module","exports","OutputLine","nextProps","nextState","canRender","clientWidth","this","props","id","enqueueLineUpdate","cls","stl","children","style","className","ref","el","checkWidth","Component","OutputChar","makeNewLine","line","copies","makeNewLines","num","Array","keys","map","minFloor","v0","v1","Math","floor","min","sameFloor","Output","window","innerWidth","innerHeight","maxWidth","maxHeight","lines","state","idealHeight","idealWidth","fontSize","label","labelWidth","bind","addCharsToLine","addCharToLine","updateShape","lineQueue","Promise","resolve","width","height","getShape","lastChar","length","offset","isSameOffset","char","lastIndex","newChar","newLine","i","j","missing","maxLines","getMaxLines","guessWidth","x","lineState","getNextOffset","concat","finishedCopy","isWholeLabel","newCopies","input","lineIdx","oldLineState","output","canLineRender","space","guessMask","newLineState","addCharToLineCore","a","v","_v","_i","immutableInsert","allReady","reduce","setState","newLines","then","onLineUpdate","newState","oldShape","numLines","addEventListener","onColumnUpdate","outlineStyle","centerStyle","outline","styles","lineStyle","top","grid","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5f8dfb02.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"outline\":\"Output_outline__30pg-\",\"line\":\"Output_line__3suFW\",\"grid\":\"Output_grid__2lwKT\"};","import React, { Component } from 'react';\n\nclass OutputLine extends Component {\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {canRender} = nextProps;\n    return canRender;\n  }\n\n  checkWidth(clientWidth) {\n    const {id, enqueueLineUpdate} = this.props;\n    enqueueLineUpdate(id, clientWidth);\n  }\n\n  render() {\n    const {cls, stl} = this.props;\n    const {children} = this.props;\n    return (\n      <div style={stl} className={cls}\n        ref={(el) => {\n          if (el) {\n            this.checkWidth(el.clientWidth);\n          }\n        }}\n      >\n        {children}\n      </div>\n    );\n  }\n}\nexport default OutputLine;\n","import React, { Fragment, Component } from 'react';\n\nclass OutputChar extends Component {\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const oldChar = this.props.children;\n    const newChar = nextProps.children;\n    return oldChar !== newChar;\n  }\n\n  render() {\n    const {children} = this.props;\n    if (children === ' ') {\n      return (\n        <Fragment>&nbsp;</Fragment>\n      );\n    }\n    return children;\n  }\n}\nexport default OutputChar;\n","import React, { Component } from 'react';\nimport styles from './Output.module.css';\nimport OutputLine from './OutputLine';\nimport OutputChar from './OutputChar';\n\n /*\nconst sleep = async (ms) => {\n  await ((ms) => {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  })();\n}\n */\n\nconst makeNewLine = (line=[]) => {\n  return {\n    clientWidth: 0,\n    line: line,\n    copies: 0\n  }\n}\n\nconst makeNewLines = (num) => {\n  const numRange = [...Array(num).keys()];\n  return numRange.map(()=>{\n    return makeNewLine([]);\n  })\n} \n\nconst immutableInsert = (a, v, i) => {\n  return a.map((_v, _i) => {\n    return (_i === i) ? v : _v;\n  })\n}\n\nconst isSameOffset = (v0, v1, label) => {\n  if ('offset' in v0 && 'offset' in v1) {\n    return v0.offset % label.length === v1.offset % label.length;\n  }\n  return false;\n}\n\nconst minFloor = (v0, v1) => {\n  return Math.floor(Math.min(v0, v1));\n}\n\nconst sameFloor = (v0, v1) => {\n  return Math.floor(v0) === Math.floor(v1);\n}\n\nclass Output extends Component {\n  constructor(props) {\n    super(props);\n    const fontSize = 12;\n    const [idealWidth, idealHeight] = [450, 950];\n    const {innerWidth, innerHeight} = window;\n    const maxWidth = minFloor(idealWidth, innerWidth);\n    const maxHeight = minFloor(idealHeight, innerHeight); \n    const lines = makeNewLines(Math.floor(maxHeight / fontSize));\n    this.state = {\n      lines,\n      idealHeight,\n      idealWidth,\n      maxHeight,\n      maxWidth,\n      fontSize,\n      label: 'missingno',\n      canRender: true,\n      labelWidth: 0\n    };\n    this.enqueueLineUpdate = this.enqueueLineUpdate.bind(this);\n    this.addCharsToLine = this.addCharsToLine.bind(this);\n    this.addCharToLine = this.addCharToLine.bind(this);\n    this.updateShape = this.updateShape.bind(this);\n    this.lineQueue = Promise.resolve(true);\n  }\n\n  getShape() {\n    const {idealWidth, idealHeight} = this.state;\n    const {maxWidth, maxHeight} = this.state;\n    return {\n      width: minFloor(idealWidth, maxWidth),\n      height: minFloor(idealHeight, maxHeight)\n    }\n  }\n\n  getMaxLines() {\n    const {fontSize} = this.state;\n    const {height} = this.getShape();\n    return Math.floor(height / fontSize);\n  }\n\n  isWholeLabel(line) {\n    const {label} = this.state;\n    const lastChar = line[line.length - 1];\n    return line.length > 1 && isSameOffset(line[0], lastChar, label);\n  }\n\n  newLine(line=[]) {\n    return makeNewLine(line);\n  }\n\n  newChar(offset, char=null) {\n    const {label} = this.state;\n    return {\n      char: char === null ? (label[offset % label.length]) : char,\n      offset: offset\n    }\n  }\n\n  getNextOffset(line, char=null) {\n    const lastIndex = line.length - 1;\n    const lastChar = line[lastIndex] || this.newChar(-1, null);\n    const offset = lastChar.offset + (char === null ? 1: 0);\n    return offset;\n  }\n\n  getLastLine(lines) {\n    const lastIndex = lines.length - 1;\n    return lines[lastIndex] || this.newLine();\n  }\n\n  guessMask(i, j) {\n    const missing = [\n      [0,0,0,0,0,0,0,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,0,0,0,0,0,0,0],\n    ];\n\n    const {width} = this.getShape();\n    const maxLines = this.getMaxLines();\n    const {lines, label, labelWidth} = this.state;\n    const {clientWidth} = lines[j];\n\n    // Convert client coords to mask coords\n    const guessCharWidth = labelWidth / label.length;\n    const guessWidth = clientWidth + i * guessCharWidth;\n    const x = Math.floor((guessWidth / width) * missing[0].length);\n    const y = Math.floor((j / maxLines) * missing.length);\n    return missing[y][x];\n  }\n\n  addCharToLineCore(lineState, char=null) {\n    const {line, copies} = lineState;\n\n    const offset = this.getNextOffset(line, char);\n    const newChar = this.newChar(offset, char);\n    const newLine = line.concat([newChar]);\n\n    const finishedCopy = this.isWholeLabel(newLine);\n    const newCopies = copies + (finishedCopy? 1 : 0);\n\n    return {\n      ...lineState,\n      line: newLine,\n      copies: newCopies\n    };\n  }\n\n  addCharToLine(input, i) {\n    const {lines, lineIdx, labelWidth} = input;\n    const oldLineState = lines[lineIdx];\n    const output = {};\n    if (oldLineState && this.canLineRender(lineIdx)) {\n      const space = this.guessMask(i, lineIdx) === 1 ? ' ' : null;\n      const newLineState = this.addCharToLineCore(oldLineState, space);\n      const {copies, clientWidth} = newLineState;\n      // Track the width of a single word\n      if (!labelWidth && copies === 1) {\n        output.labelWidth = clientWidth;\n      }\n      output.lines = immutableInsert(lines, newLineState, lineIdx);\n      output.allReady = false;\n    }\n    return { \n      ...input,\n      ...output\n    };\n  }\n\n  addCharsToLine(input, lineIdx) {\n    const {num, lines} = input;\n    const {labelWidth, allReady} = input;\n    const numRange = [...Array(num).keys()];\n    const output = numRange.reduce(this.addCharToLine, {\n      lines,\n      lineIdx,\n      labelWidth,\n      allReady\n    });\n    return {\n      ...input,\n      ...output\n    };\n  }\n\n  onColumnUpdate() {\n    return new Promise((resolve) => {\n      const {lines, labelWidth} = this.state;\n      const lineRange = [...lines.keys()];\n      const output = lineRange.reduce(this.addCharsToLine, {\n        labelWidth, lines, allReady: true, num: 1 \n      });\n\n      if (output.allReady) {\n        return resolve();\n      }\n      this.setState({\n        canRender: true,\n        lines: output.lines,\n        labelWidth: output.labelWidth\n      }, resolve);\n    });\n  }\n\n  onLineUpdate(id, clientWidth) {\n    return new Promise((resolve) => {\n      const {lines} = this.state;\n      if (id < lines.length) {\n        const newLines = lines.map((lineState, i) => {\n          if (id === i) {\n            return {\n              ...lineState,\n              clientWidth: clientWidth\n            };\n          }\n          return lineState;\n        });\n        this.setState({\n          canRender: false,\n          lines: newLines\n        }, resolve);\n      }\n    });\n  }\n\n  enqueueLineUpdate(id, clientWidth) {\n    this.lineQueue.then(async () => {\n      return await this.onLineUpdate(id, clientWidth);\n    })\n  }\n\n  canLineRender(id) {\n    const {lines} = this.state;\n    const {width} = this.getShape();\n    const lineState = lines[id];\n    if (!lineState) {\n      return false;\n    }\n    const {clientWidth} = lineState;\n    const remaining = width - clientWidth;\n    return remaining > 0;\n  }\n\n  updateShape() {\n    const newState = {};\n    const oldShape = this.getShape();\n    const {maxWidth, maxHeight, fontSize} = this.state;\n    const {innerWidth, innerHeight} = window;\n\n    if (!sameFloor(maxWidth, innerWidth)) {\n      newState.maxWidth = Math.floor(innerWidth);\n    }\n    if (!sameFloor(maxHeight, innerHeight)) {\n      newState.maxHeight = Math.floor(innerHeight);\n    }\n    this.setState(newState, async () => {\n      const {height, width} = this.getShape();\n      // No need to redraw output if the shape has not changed\n      if (oldShape.height === height && oldShape.width === width) {\n        return;\n      }\n      await this.lineQueue;\n      const numLines = Math.floor(height / fontSize);\n      this.setState({\n        canRender: true,\n        lines: makeNewLines(numLines)\n      });\n    });\n  }\n\n  async componentDidMount() {\n    window.addEventListener('resize', this.updateShape);\n    await this.onColumnUpdate();\n  }\n\n  async componentDidUpdate() {\n    //await sleep(10); //sleep is easier on the eyes in dev mode\n    await this.lineQueue;\n    await this.onColumnUpdate();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {canRender} = nextState;\n    return canRender;\n  }\n\n  render() {\n    const {fontSize} = this.state;\n    const {lines, labelWidth} = this.state;\n    const {width, height} = this.getShape();\n\n    const outlineStyle = {\n      fontSize: `${fontSize}px`,\n    };\n    const centerStyle = {\n      'width': `${width}px`,\n      'height': `${height}px`\n    };\n\n    const outline = (\n      <div style={outlineStyle} className={styles.outline}>\n        {lines.map(({line, copies}, i) => {\n          const lineStyle ={\n            top: i * fontSize\n          };\n          return (\n            <OutputLine enqueueLineUpdate={this.enqueueLineUpdate}\n              labelWidth={labelWidth} copies={copies}\n              canRender={this.canLineRender(i)}\n              stl={lineStyle} cls={styles.line} key={i} id={i}\n            >\n              {line.map(({char}, j) => {\n                return (\n                  <OutputChar key={j}>\n                    {char}\n                  </OutputChar>\n                );\n              })}\n            </OutputLine>\n          );\n        })}\n      </div>\n    );\n    return (\n      <div className={styles.grid}>\n        <div></div>\n        <div style={centerStyle}>\n          {outline}\n        </div>\n        <div></div>\n      </div>\n    )\n  }\n}\nexport default Output;\n","import Output from './Output.js';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div>\n        Hello Missingno\n      </div>\n      <Output>\n      </Output>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './containers/App';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}