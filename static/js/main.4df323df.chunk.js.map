{"version":3,"sources":["containers/Output.module.css","containers/OutputLine.js","containers/OutputChar.js","containers/Output.js","containers/App.js","index.js"],"names":["module","exports","OutputLine","nextProps","nextState","canRender","clientWidth","this","props","id","enqueueLineUpdate","cls","stl","children","style","className","ref","el","width","getBoundingClientRect","checkWidth","Component","OutputChar","makeNewLine","line","numRenders","elWidthDiff","elWidth","makeNewLines","num","Array","keys","map","readLastChar","lineState","slice","copyWidthMap","widthMap","char","has","constMapInsert","Math","abs","a","i","v","Map","constListReplace","_v","_i","minFloor","v0","v1","floor","min","sameFloor","indexLabel","label","offset","length","debounceAsync","fn","t","debounced","debounce","args","Promise","resolve","apply","then","result","catch","Output","window","innerWidth","innerHeight","maxWidth","maxHeight","lines","state","idealHeight","idealWidth","fontSize","updateShape","bind","resetLines","addCharsToLine","addCharToLine","lineQueue","height","getShape","increment","prior","reduce","off","done","sumWidth","offWidth","get","max","alignment","space","getNextOffsetByColumn","getNextOffset","newChar","newLine","lineIdx","maxLines","getMaxLines","widthRatio","heightRatio","getRatios","input","checkRatios","ratios","missing","x","getNextChar","hiddenChars","concat","nextChar","readMask","iMax","charWidth","nextWidth","some","canLineRender","output","allReady","split","hiddenLine","listHiddenChars","stepSize","setState","updateLine","onLineUpdate","newState","oldShape","numLines","addEventListener","onColumnUpdate","outlineStyle","centerStyle","outline","styles","lineStyle","top","ii","grid","RenderOutput","App","basename","process","path","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4df323df.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"outline\":\"Output_outline__30pg-\",\"line\":\"Output_line__3suFW\",\"grid\":\"Output_grid__2lwKT\"};","import React, { Component } from 'react';\n\nclass OutputLine extends Component {\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {canRender} = nextProps;\n    return canRender;\n  }\n\n  checkWidth(clientWidth) {\n    const {id, enqueueLineUpdate} = this.props;\n    enqueueLineUpdate(id, clientWidth);\n  }\n\n  render() {\n    const {cls, stl} = this.props;\n    const {children} = this.props;\n    return (\n      <div style={stl} className={cls}\n        ref={(el) => {\n          if (el) {\n          const {width} = el.getBoundingClientRect();\n            this.checkWidth(width);\n          }\n        }}\n      >\n        {children}\n        <br/>\n      </div>\n    );\n  }\n}\nexport default OutputLine;\n","import React, { Fragment, Component } from 'react';\n\nclass OutputChar extends Component {\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const oldChar = this.props.children;\n    const newChar = nextProps.children;\n    return oldChar !== newChar;\n  }\n\n  render() {\n    const {children} = this.props;\n    if (children === ' ') {\n      return (\n        <Fragment>&nbsp;</Fragment>\n      );\n    }\n    return children;\n  }\n}\nexport default OutputChar;\n","import React, { Component } from 'react';\nimport debounce from 'debounce-async';\nimport styles from './Output.module.css';\nimport OutputLine from './OutputLine';\nimport OutputChar from './OutputChar';\n\n/*\nconst sleep = async (ms) => {\n  return await ((ms) => {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  })();\n}*/\n\nconst makeNewLine = (line=[]) => {\n  return {\n    numRenders: 0,\n    elWidthDiff: 0,\n    elWidth: 0,\n    line: line\n  }\n}\n\nconst makeNewLines = (num) => {\n  const numRange = [...Array(num).keys()];\n  return numRange.map(()=>{\n    return makeNewLine([]);\n  })\n} \n\nconst readLastChar = (lineState) => {\n  const {line} = lineState;\n  return line.slice(-1)[0];\n}\n\nconst copyWidthMap = (widthMap, char, elWidthDiff) => {\n  if (char && elWidthDiff !== 0 && !widthMap.has(char)) {\n    return constMapInsert(widthMap, char, Math.abs(elWidthDiff));\n  }\n  return widthMap;\n}\n\nconst constMapInsert = (a, i, v) => {\n  return new Map([ ...a, [i, v] ]);\n}\n\nconst constListReplace = (a, i, v) => {\n  return a.map((_v, _i) => {\n    return (_i === i) ? v : _v;\n  })\n}\n\nconst minFloor = (v0, v1) => {\n  return Math.floor(Math.min(v0, v1));\n}\n\nconst sameFloor = (v0, v1) => {\n  return Math.floor(v0) === Math.floor(v1);\n}\n\nconst indexLabel = (label, offset) => {\n  return label[offset % label.length];\n}\n\nconst debounceAsync = (fn, t) => {\n  const debounced = debounce(fn, t);\n  return async function(...args) {\n    return await new Promise((resolve)=>{\n      debounced.apply(this, args)\n        .then((result)=>{resolve(result)})\n        .catch(()=>{resolve(null)});\n    });\n  }\n}\n\nclass Output extends Component {\n  constructor(props) {\n    super(props);\n    const fontSize = 16;\n    const label = 'missingno';\n    const [idealWidth, idealHeight] = [450, 950];\n    const {innerWidth, innerHeight} = window;\n    const maxWidth = minFloor(idealWidth, innerWidth);\n    const maxHeight = minFloor(idealHeight, innerHeight); \n    const lines = makeNewLines(Math.floor(maxHeight / fontSize));\n    this.state = {\n      lines,\n      idealHeight,\n      idealWidth,\n      maxHeight,\n      maxWidth,\n      fontSize,\n      label: label,\n      canRender: true,\n      widthMap: new Map()\n    };\n    this.updateShape = debounceAsync(this.updateShape, 333).bind(this);\n    this.resetLines = debounceAsync(this.resetLines, 333).bind(this);\n    this.enqueueLineUpdate = this.enqueueLineUpdate.bind(this);\n    this.addCharsToLine = this.addCharsToLine.bind(this);\n    this.addCharToLine = this.addCharToLine.bind(this);\n    this.lineQueue = Promise.resolve(true);\n  }\n\n  getShape() {\n    const {idealWidth, idealHeight} = this.state;\n    const {maxWidth, maxHeight} = this.state;\n    return {\n      width: minFloor(idealWidth, maxWidth),\n      height: minFloor(idealHeight, maxHeight)\n    }\n  }\n\n  getMaxLines() {\n    const {fontSize} = this.state;\n    const {height} = this.getShape();\n    return Math.floor(height / fontSize);\n  }\n\n  newLine(line=[]) {\n    return makeNewLine(line);\n  }\n\n  newChar({offset=-1, char='?'}) {\n    // Offset of -1 means hidden\n    return {\n      offset: offset,\n      char: char\n    };\n  }\n\n  getNextOffsetByColumn(lineState, increment) {\n    const {elWidth} = lineState;\n    const {width} = this.getShape();\n    const {label, widthMap} = this.state;\n    const maxRange = [...Array(width).keys()];\n    const {prior} = maxRange.reduce((result, off) => {\n      const {done, prior, sumWidth} = result;\n      const offWidth = widthMap.get(indexLabel(label, off)) || 0;\n      if (done || sumWidth + offWidth > elWidth + offWidth/2) {\n        return {done: true, prior, sumWidth};\n      }\n      return {\n        prior: off,\n        done: false,\n        sumWidth: sumWidth + offWidth\n      }\n    }, {\n      prior: -1,\n      sumWidth: 0,\n      done: false\n    });\n    return Math.max(prior + increment, 0);\n  }\n\n  getNextOffset(lineState, increment) {\n    const {offset} = readLastChar(lineState) || {\n      offset: -1\n    };\n    return Math.max(offset + increment, 0);\n  }\n\n  getNextChar(lineState, increment) {\n    const {label} = this.state;\n    const {alignment, space} = this.props;\n    const offset = (()=>{\n      if (alignment === 'column' && increment > 0) {\n        const {char} = readLastChar(lineState) || {};\n        if (char === space) {\n          return this.getNextOffsetByColumn(lineState, increment);\n        }\n      }\n      return this.getNextOffset(lineState, increment);\n    })();\n    const char = indexLabel(label, offset);\n    return this.newChar({offset, char});\n  }\n\n  getLastLine(lines) {\n    return lines.slice(-1)[0] || this.newLine();\n  }\n\n  getRatios(elWidth, lineIdx) {\n    const maxLines = this.getMaxLines();\n    const {width} = this.getShape();\n    return {\n      widthRatio: elWidth / width,\n      heightRatio: (lineIdx + 0.5) / maxLines\n    };\n  }\n\n  checkRatios(elWidth, lineIdx) {\n    const {widthRatio, heightRatio} = this.getRatios(elWidth, lineIdx);\n    if (widthRatio > 1 || heightRatio > 1) {\n      return false;\n    }\n    return true;\n  }\n\n  readMask(input) {\n    const {lineState, lineIdx} = input;\n    const {elWidth} = lineState;\n    if (!this.checkRatios(elWidth, lineIdx)) {\n      return null;\n    }\n    const ratios = this.getRatios(elWidth, lineIdx);\n    const {widthRatio, heightRatio} = ratios;\n\n    const missing = [\n      [0,0,0,0,0,0,0,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,0,0,0,0,0,0,0],\n    ];\n\n    // Convert element coords to mask coords\n    const x = Math.floor(widthRatio * missing[0].length);\n    const y = Math.floor(heightRatio * missing.length);\n\n    // Return correct character\n    if (missing[y][x]) {\n      const {space} = this.props;\n      return this.newChar({\n        offset: this.getNextOffset(lineState, 0),\n        char: space\n      });\n    }\n    return this.getNextChar(lineState, 1);\n  }\n\n  addCharToLine(input, i) {\n    if (input.done) {\n      return input;\n    }\n\n    const {lineState, hiddenChars} = input;\n    if (hiddenChars.length > 0 && lineState.line.length > 0) {\n      return {\n        ...input,\n        done: true,\n        lineState: {\n          ...lineState,\n          line: lineState.line.concat([\n            hiddenChars.slice(-1)[0]\n          ]),\n        },\n        hiddenChars: hiddenChars.slice(0,-1)\n      };\n    }\n\n    const nextChar = this.readMask(input);\n    if (nextChar === null) {\n      return input;\n    }\n    const {char} = nextChar;\n    const {lineIdx, iMax} = input;\n    const {elWidth} = lineState;\n    const {widthMap} = this.state;\n    const charWidth = widthMap.get(char) || 0;\n    const nextWidth = elWidth + charWidth;\n    const inBounds = this.checkRatios(nextWidth, lineIdx);\n    if (!inBounds) {\n      return {\n        ...input,\n        done: true\n      }\n    }\n\n    const done = [\n      i === iMax, // final character estimate\n      charWidth < 1 // no valid character estimate\n    ].some(x=>x);\n\n    return {\n      ...input,\n      lineState: {\n        ...lineState,\n        line: lineState.line.concat([nextChar]),\n        elWidth: (done ? elWidth : nextWidth)\n      },\n      done\n    };\n  }\n\n  addCharsToLine(input, lineState, lineIdx) {\n    const {num, lines, hiddenChars} = input;\n    // Line is ready to go\n    if (!this.canLineRender(lineState)) {\n      return input;\n    }\n\n    const numRange = [...Array(num).keys()];\n    const output = numRange.reduce(this.addCharToLine, {\n      iMax: num - 1, done: false, lineState, lineIdx,\n      hiddenChars: hiddenChars\n    });\n\n    return {\n      ...input,\n      allReady: false,\n      hiddenChars: output.hiddenChars,\n      lines: constListReplace(lines, lineIdx, output.lineState),\n    };\n  }\n\n  listHiddenChars() {\n    const {space} = this.props;\n    const {widthMap, label} = this.state;\n    const neededChars = label.split('').concat([space]);\n    return neededChars.reduce((hiddenLine, char) => {\n      if (widthMap.has(char)) {\n        return hiddenLine;\n      }\n      return [\n        this.newChar({\n          char: char,\n          offset: -1\n        }),\n        ...hiddenLine\n      ];\n    }, []);\n  }\n\n  onColumnUpdate() {\n    return new Promise((resolve) => {\n      const {lines} = this.state;\n      const output = lines.reduce(this.addCharsToLine, {\n        hiddenChars: this.listHiddenChars(),\n        num: this.props.stepSize,\n        allReady: true,\n        lines\n      });\n\n      if (output.allReady) {\n        return this.setState({\n          canRender: false,\n        }, resolve);\n      }\n      return this.setState({\n        canRender: true,\n        lines: output.lines,\n      }, resolve);\n    });\n  }\n\n  updateLine(lineState, elWidth) {\n    const {width} = this.getShape();\n    const {numRenders} = lineState;\n    const {offset} = readLastChar(lineState) || {\n      offset: 0\n    };\n    // If at end of line or hidden character\n    if (elWidth > width || offset < 0) {\n      // We will measure a negative element width\n      return {\n        ...lineState,\n        line: lineState.line.slice(0, -1),\n        elWidthDiff: lineState.elWidth - elWidth\n      };\n    }\n    return {\n      ...lineState,\n      elWidth: elWidth,\n      numRenders: numRenders + 1,\n      elWidthDiff: elWidth - lineState.elWidth\n    };\n  }\n\n  onLineUpdate(id, elWidth) {\n    return new Promise((resolve) => {\n      const {lines, widthMap} = this.state;\n      if (id < lines.length) {\n        const {char} = readLastChar(lines[id]) || {};\n        const lineState = this.updateLine(lines[id], elWidth);\n        const {elWidthDiff} = lineState;\n        this.setState({\n          widthMap: copyWidthMap(widthMap, char, elWidthDiff),\n          lines: constListReplace(lines, id, lineState),\n          canRender: false\n        }, resolve);\n      }\n    });\n  }\n\n  enqueueLineUpdate(id, elWidth) {\n    this.lineQueue.then(async () => {\n      return await this.onLineUpdate(id, elWidth);\n    })\n  }\n\n  canLineRender(lineState) {\n    if (!lineState) {\n      return false;\n    }\n    const {numRenders, elWidthDiff} = lineState;\n    const endReached = (\n      numRenders >= 2 && (elWidthDiff === 0)\n    );\n    return !endReached;\n  }\n\n  // debounced\n  async updateShape() {\n    const newState = {};\n    const oldShape = this.getShape();\n    const {maxWidth, maxHeight, fontSize} = this.state;\n    const {innerWidth, innerHeight} = window;\n\n    if (!sameFloor(maxWidth, innerWidth)) {\n      newState.maxWidth = Math.floor(innerWidth);\n    }\n    if (!sameFloor(maxHeight, innerHeight)) {\n      newState.maxHeight = Math.floor(innerHeight);\n    }\n    this.setState(newState, async () => {\n      const {height, width} = this.getShape();\n      // No need to redraw output if the shape has not changed\n      if (oldShape.height === height && oldShape.width === width) {\n        return;\n      }\n      await this.lineQueue;\n      const numLines = Math.floor(height / fontSize);\n      this.setState({\n        canRender: true,\n        lines: makeNewLines(numLines)\n      });\n    });\n  }\n\n  // debounced\n  async resetLines() {\n    const {lines} = this.state;\n    await this.lineQueue;\n    this.setState({\n      canRender: true,\n      lines: makeNewLines(lines.length)\n    });\n  }\n\n  async componentDidMount() {\n    window.addEventListener('resize', async() => {\n      await this.updateShape();\n    });\n    await this.onColumnUpdate();\n  }\n\n  async componentDidUpdate() {\n    //await sleep(1); //sleep helps debug in dev mode\n    await this.lineQueue;\n    await this.onColumnUpdate();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {alignment} = this.props;\n    // Redraw completely if step size changes\n    if (nextProps.alignment !== alignment) {\n      this.resetLines();\n      return false;\n    }\n    const {canRender} = nextState;\n    return canRender;\n  }\n\n  render() {\n    const {fontSize} = this.state;\n    const {lines} = this.state;\n    const {width, height} = this.getShape();\n\n    const outlineStyle = {\n      fontSize: `${fontSize}px`,\n    };\n    const centerStyle = {\n      'width': `${width}px`,\n      'height': `${height}px`\n    };\n\n    const outline = (\n      <div style={outlineStyle} className={styles.outline}>\n        {lines.map((lineState, i) => {\n          const lineStyle ={\n            top: i * fontSize\n          };\n          return (\n            <OutputLine enqueueLineUpdate={this.enqueueLineUpdate}\n              canRender={this.canLineRender(lineState)}\n              stl={lineStyle} cls={styles.line} key={i} id={i}\n            >\n              {lineState.line.map(({char}, ii) => {\n                return (\n                  <OutputChar key={ii}>\n                    {char}\n                  </OutputChar>\n                );\n              })}\n            </OutputLine>\n          );\n        })}\n      </div>\n    );\n    return (\n      <div className={styles.grid}>\n        <div></div>\n        <div style={centerStyle}>\n          {outline}\n        </div>\n        <div></div>\n      </div>\n    )\n  }\n}\nexport default Output;\n","import React from \"react\";\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\n\nimport Output from './Output.js';\n\nfunction RenderOutput({alignment}) {\n  return (\n    <Output space=' ' stepSize={100}\n      alignment={alignment}\n    >\n    </Output>\n  );\n}\n\nfunction App() {\n\n  return (\n    <Router basename={process.env.PUBLIC_URL}>\n      <div className=\"App\">\n        <Switch>\n          <Route path=\"/row\">\n            {RenderOutput({alignment:'row'})}\n          </Route>\n          <Route path=\"/\">\n            {RenderOutput({alignment:'column'})}\n          </Route>\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './containers/App';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}