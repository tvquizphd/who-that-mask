{"version":3,"sources":["containers/Output.module.css","containers/OutputLine.js","containers/OutputChar.js","containers/Output.js","containers/App.js","index.js"],"names":["module","exports","OutputLine","nextProps","nextState","canRender","clientWidth","this","props","id","enqueueLineUpdate","cls","stl","children","style","className","ref","el","width","getBoundingClientRect","checkWidth","Component","OutputChar","makeNewLine","line","elWidthDiff","elWidth","numRenders","makeNewLines","num","Array","keys","map","copyWidthMap","widthMap","lineState","charState","length","char","has","constMapInsert","a","i","v","Map","constListReplace","_v","_i","minFloor","v0","v1","Math","floor","min","sameFloor","debounceAsync","fn","t","debounced","debounce","args","Promise","resolve","apply","then","result","catch","Output","window","innerWidth","innerHeight","maxWidth","maxHeight","lines","state","idealHeight","idealWidth","fontSize","label","updateShape","bind","resetLines","addCharsToLine","addCharToLine","lineQueue","height","getShape","offset","increment","getNextOffset","newChar","newLine","lineIdx","maxLines","getMaxLines","widthRatio","heightRatio","getRatios","input","checkRatios","ratios","missing","x","getNextChar","done","nextChar","readMask","iMax","charWidth","get","nextWidth","some","concat","canLineRender","allReady","output","reduce","stepSize","setState","slice","updateLine","onLineUpdate","newState","oldShape","numLines","addEventListener","onColumnUpdate","outlineStyle","centerStyle","outline","styles","lineStyle","top","ii","grid","App","useState","setStepSize","type","max","value","onChange","event","parseInt","target","step","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.af04651f.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"outline\":\"Output_outline__30pg-\",\"line\":\"Output_line__3suFW\",\"grid\":\"Output_grid__2lwKT\"};","import React, { Component } from 'react';\n\nclass OutputLine extends Component {\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {canRender} = nextProps;\n    return canRender;\n  }\n\n  checkWidth(clientWidth) {\n    const {id, enqueueLineUpdate} = this.props;\n    enqueueLineUpdate(id, clientWidth);\n  }\n\n  render() {\n    const {cls, stl} = this.props;\n    const {children} = this.props;\n    return (\n      <div style={stl} className={cls}\n        ref={(el) => {\n          if (el) {\n          const {width} = el.getBoundingClientRect();\n            this.checkWidth(width);\n          }\n        }}\n      >\n        {children}\n        <br/>\n      </div>\n    );\n  }\n}\nexport default OutputLine;\n","import React, { Fragment, Component } from 'react';\n\nclass OutputChar extends Component {\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const oldChar = this.props.children;\n    const newChar = nextProps.children;\n    return oldChar !== newChar;\n  }\n\n  render() {\n    const {children} = this.props;\n    if (children === ' ') {\n      return (\n        <Fragment>&nbsp;</Fragment>\n      );\n    }\n    return children;\n  }\n}\nexport default OutputChar;\n","import React, { Component } from 'react';\nimport debounce from 'debounce-async';\nimport styles from './Output.module.css';\nimport OutputLine from './OutputLine';\nimport OutputChar from './OutputChar';\n\n/*\nconst sleep = async (ms) => {\n  return await ((ms) => {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  })();\n}*/\n\nconst makeNewLine = (line=[]) => {\n  return {\n    elWidthDiff: 0,\n    elWidth: 0,\n    numRenders: 0,\n    line: line\n  }\n}\n\nconst makeNewLines = (num) => {\n  const numRange = [...Array(num).keys()];\n  return numRange.map(()=>{\n    return makeNewLine([]);\n  })\n} \n\nconst copyWidthMap = (widthMap, lineState) => {\n  const {line, elWidthDiff} = lineState;\n  const charState = line[line.length - 1];\n  const {char} = charState || {};\n  if (charState && elWidthDiff > 0 && !widthMap.has(char)) {\n    return constMapInsert(widthMap, char, elWidthDiff);\n  }\n  return widthMap;\n}\n\nconst constMapInsert = (a, i, v) => {\n  return new Map([ ...a, [i, v] ]);\n}\n\nconst constListReplace = (a, i, v) => {\n  return a.map((_v, _i) => {\n    return (_i === i) ? v : _v;\n  })\n}\n\nconst minFloor = (v0, v1) => {\n  return Math.floor(Math.min(v0, v1));\n}\n\nconst sameFloor = (v0, v1) => {\n  return Math.floor(v0) === Math.floor(v1);\n}\n\nconst debounceAsync = (fn, t) => {\n  const debounced = debounce(fn, t);\n  return async function(...args) {\n    return await new Promise((resolve)=>{\n      debounced.apply(this, args)\n        .then((result)=>{resolve(result)})\n        .catch(()=>{resolve(null)});\n    });\n  }\n}\n\nclass Output extends Component {\n  constructor(props) {\n    super(props);\n    const fontSize = 16;\n    const label = 'missingno'\n    const [idealWidth, idealHeight] = [450, 950];\n    const {innerWidth, innerHeight} = window;\n    const maxWidth = minFloor(idealWidth, innerWidth);\n    const maxHeight = minFloor(idealHeight, innerHeight); \n    const lines = makeNewLines(Math.floor(maxHeight / fontSize));\n    this.state = {\n      lines,\n      idealHeight,\n      idealWidth,\n      maxHeight,\n      maxWidth,\n      fontSize,\n      widthMap: new Map(),\n      label: label,\n      canRender: true\n    };\n    this.updateShape = debounceAsync(this.updateShape, 333).bind(this);\n    this.resetLines = debounceAsync(this.resetLines, 333).bind(this);\n    this.enqueueLineUpdate = this.enqueueLineUpdate.bind(this);\n    this.addCharsToLine = this.addCharsToLine.bind(this);\n    this.addCharToLine = this.addCharToLine.bind(this);\n    this.lineQueue = Promise.resolve(true);\n  }\n\n  getShape() {\n    const {idealWidth, idealHeight} = this.state;\n    const {maxWidth, maxHeight} = this.state;\n    return {\n      width: minFloor(idealWidth, maxWidth),\n      height: minFloor(idealHeight, maxHeight)\n    }\n  }\n\n  getMaxLines() {\n    const {fontSize} = this.state;\n    const {height} = this.getShape();\n    return Math.floor(height / fontSize);\n  }\n\n  newLine(line=[]) {\n    return makeNewLine(line);\n  }\n\n  newChar(offset, char) {\n    return { offset, char };\n  }\n\n  getNextOffset(line, increment) {\n    const lastIndex = line.length - 1;\n    const {offset} = line[lastIndex] || {offset: -1};\n    return offset + increment;\n  }\n\n  getNextChar(line, increment) {\n    const {label} = this.state;\n    const offset = this.getNextOffset(line, increment);\n    const char = label[offset % label.length];\n    return this.newChar(offset, char);\n  }\n\n  getLastLine(lines) {\n    const lastIndex = lines.length - 1;\n    return lines[lastIndex] || this.newLine();\n  }\n\n  getRatios(elWidth, lineIdx) {\n    const maxLines = this.getMaxLines();\n    const {width} = this.getShape();\n    return {\n      widthRatio: elWidth / width,\n      heightRatio: (lineIdx + 0.5) / maxLines\n    };\n  }\n\n  checkRatios(elWidth, lineIdx) {\n    const {widthRatio, heightRatio} = this.getRatios(elWidth, lineIdx);\n    if (widthRatio > 1 || heightRatio > 1) {\n      return false;\n    }\n    return true;\n  }\n\n  readMask(input) {\n    const {lineState, lineIdx} = input;\n    const {line, elWidth} = lineState;\n    if (!this.checkRatios(elWidth, lineIdx)) {\n      return null;\n    }\n    const ratios = this.getRatios(elWidth, lineIdx);\n    const {widthRatio, heightRatio} = ratios;\n\n    const missing = [\n      [0,0,0,0,0,0,0,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,0,0,0,0,0,0,0],\n    ];\n\n    // Convert element coords to mask coords\n    const x = Math.floor(widthRatio * missing[0].length);\n    const y = Math.floor(heightRatio * missing.length);\n\n    // Return correct character\n    if (missing[y][x]) {\n      return this.newChar(this.getNextOffset(line, 0), ' ');\n    }\n    return this.getNextChar(line, 1);\n  }\n\n  addCharToLine(input, i) {\n    if (input.done) {\n      return input;\n    }\n    const nextChar = this.readMask(input);\n    if (nextChar === null) {\n      return input;\n    }\n    const {char} = nextChar;\n    const {lineIdx, iMax} = input;\n    const {lineState, widthMap} = input;\n    const {elWidth} = lineState;\n    const charWidth = widthMap.get(char) || 0;\n    const nextWidth = elWidth + charWidth;\n\n    const done = [\n      i === iMax, // final character estimate\n      charWidth < 1, // no valid character estimate\n      !this.checkRatios(nextWidth, lineIdx) // out of bounds\n    ].some(x=>x);\n\n    return {\n      ...input,\n      lineState: {\n        ...lineState,\n        line: lineState.line.concat([nextChar]),\n        elWidth: (done ? elWidth : nextWidth)\n      },\n      done\n    };\n  }\n\n  addCharsToLine(input, lineState, lineIdx) {\n    const {num, lines, widthMap} = input;\n    // Line is ready to go\n    if (!this.canLineRender(lineIdx)) {\n      return input;\n    }\n    // Line has just been backspaced \n    if (lineState.elWidthDiff < 0) {\n      return {\n        ...input,\n        allReady: false\n      };\n    }\n\n    const numRange = [...Array(num).keys()];\n    const output = numRange.reduce(this.addCharToLine, {\n      widthMap: copyWidthMap(widthMap, lineState),\n      iMax: num - 1, done: false, lineState, lineIdx\n    });\n\n    return {\n      ...input,\n      allReady: false,\n      widthMap: output.widthMap,\n      lines: constListReplace(lines, lineIdx, output.lineState),\n    };\n  }\n\n  onColumnUpdate() {\n    return new Promise((resolve) => {\n      const {lines, widthMap} = this.state;\n      const output = lines.reduce(this.addCharsToLine, {\n        widthMap: new Map([...widthMap]),\n        num: this.props.stepSize,\n        allReady: true,\n        lines\n      });\n\n      if (output.allReady) {\n        return this.setState({\n          canRender: false,\n        }, resolve);\n      }\n      return this.setState({\n        canRender: true,\n        lines: output.lines,\n        widthMap: output.widthMap\n      }, resolve);\n    });\n  }\n\n  updateLine(lineState, elWidth) {\n    const {width} = this.getShape();\n    const {numRenders} = lineState;\n    if (elWidth > width) {\n      // We will measure a negative element width\n      return {\n        ...lineState,\n        numRenders: numRenders + 1,\n        line: lineState.line.slice(0, -1),\n        elWidthDiff: lineState.elWidth - elWidth\n      };\n    }\n    return {\n      ...lineState,\n      elWidth: elWidth,\n      numRenders: numRenders + 1,\n      elWidthDiff: elWidth - lineState.elWidth\n    };\n  }\n\n  onLineUpdate(id, elWidth) {\n    return new Promise((resolve) => {\n      const {lines} = this.state;\n      if (id < lines.length) {\n        const lineState = this.updateLine(lines[id], elWidth);\n        this.setState({\n          lines: constListReplace(lines, id, lineState),\n          canRender: false\n        }, resolve);\n      }\n    });\n  }\n\n  enqueueLineUpdate(id, elWidth) {\n    this.lineQueue.then(async () => {\n      return await this.onLineUpdate(id, elWidth);\n    })\n  }\n\n  canLineRender(id) {\n    const {lines} = this.state;\n    const lineState = lines[id];\n    if (!lineState) {\n      return false;\n    }\n    const {numRenders, elWidthDiff} = lineState;\n    const endReached = (\n      numRenders >= 2 && (elWidthDiff === 0)\n    );\n    return !endReached;\n  }\n\n  // debounced\n  async updateShape() {\n    const newState = {};\n    const oldShape = this.getShape();\n    const {maxWidth, maxHeight, fontSize} = this.state;\n    const {innerWidth, innerHeight} = window;\n\n    if (!sameFloor(maxWidth, innerWidth)) {\n      newState.maxWidth = Math.floor(innerWidth);\n    }\n    if (!sameFloor(maxHeight, innerHeight)) {\n      newState.maxHeight = Math.floor(innerHeight);\n    }\n    this.setState(newState, async () => {\n      const {height, width} = this.getShape();\n      // No need to redraw output if the shape has not changed\n      if (oldShape.height === height && oldShape.width === width) {\n        return;\n      }\n      await this.lineQueue;\n      const numLines = Math.floor(height / fontSize);\n      this.setState({\n        canRender: true,\n        lines: makeNewLines(numLines)\n      });\n    });\n  }\n\n  // debounced\n  async resetLines() {\n    const {lines} = this.state;\n    await this.lineQueue;\n    this.setState({\n      canRender: true,\n      lines: makeNewLines(lines.length)\n    });\n  }\n\n  async componentDidMount() {\n    window.addEventListener('resize', async() => {\n      await this.updateShape();\n    });\n    await this.onColumnUpdate();\n  }\n\n  async componentDidUpdate() {\n    //await sleep(1); //sleep helps debug in dev mode\n    await this.lineQueue;\n    await this.onColumnUpdate();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {stepSize} = this.props;\n    // Redraw completely if step size changes\n    if (nextProps.stepSize !== stepSize) {\n      this.resetLines();\n      return false;\n    }\n    const {canRender} = nextState;\n    return canRender;\n  }\n\n  render() {\n    const {fontSize} = this.state;\n    const {lines} = this.state;\n    const {width, height} = this.getShape();\n\n    const outlineStyle = {\n      fontSize: `${fontSize}px`,\n    };\n    const centerStyle = {\n      'width': `${width}px`,\n      'height': `${height}px`\n    };\n\n    const outline = (\n      <div style={outlineStyle} className={styles.outline}>\n        {lines.map(({line}, i) => {\n          const lineStyle ={\n            top: i * fontSize\n          };\n          return (\n            <OutputLine enqueueLineUpdate={this.enqueueLineUpdate}\n              canRender={this.canLineRender(i)}\n              stl={lineStyle} cls={styles.line} key={i} id={i}\n            >\n              {line.map(({char}, ii) => {\n                return (\n                  <OutputChar key={ii}>\n                    {char}\n                  </OutputChar>\n                );\n              })}\n            </OutputLine>\n          );\n        })}\n      </div>\n    );\n    return (\n      <div className={styles.grid}>\n        <div></div>\n        <div style={centerStyle}>\n          {outline}\n        </div>\n        <div></div>\n      </div>\n    )\n  }\n}\nexport default Output;\n","import React, { useState } from \"react\";\nimport Output from './Output.js';\n\nfunction App() {\n  const [stepSize, setStepSize] = useState(100);\n\n  return (\n    <div className=\"App\">\n      <div>\n        Speed:\n        <input \n          id=\"typeinp\" \n          type=\"range\" \n          min=\"1\" max=\"100\" \n          value={stepSize} \n          onChange={(event) =>{\n            setStepSize(parseInt(event.target.value));\n          }}\n          step=\"1\"/>\n        {stepSize}\n      </div>\n      <Output stepSize={stepSize}>\n      </Output>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './containers/App';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}