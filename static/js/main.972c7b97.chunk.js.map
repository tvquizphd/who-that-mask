{"version":3,"sources":["containers/OutputLine.js","containers/OutputChar.js","containers/Output.js","containers/App.js","index.js","containers/Output.module.css"],"names":["OutputLine","nextProps","nextState","ready","this","props","newReady","clientWidth","id","fullWidth","onLineReady","addChars","remaining","labelWidth","copies","Math","floor","cls","stl","children","style","className","ref","el","checkWidth","Component","OutputChar","makeNewLine","line","minFloor","v0","v1","min","sameFloor","Output","SHAPE","window","innerWidth","innerHeight","state","maxHeight","maxWidth","idealHeight","idealWidth","fontSize","lines","label","bind","updateShape","newState","setState","width","height","getShape","lastChar","length","offset","isSameOffset","char","lastIndex","newChar","newLine","lineState","getNextOffset","concat","finishedCopy","isWholeLabel","newCopies","num","missing","maxLines","getMaxLines","Array","keys","reduce","output","i","space","guessCharWidth","guessWidth","x","y","guessMask","lastLine","addCharToLine","getLastLine","newLines","slice","numRange","console","error","map","addEventListener","timer","setInterval","addLines","clearInterval","outlineStyle","centerStyle","outline","styles","lineStyle","top","j","grid","App","ReactDOM","render","StrictMode","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.972c7b97.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nclass OutputLine extends Component {\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {ready} = this.props;\n    const newReady = nextProps.ready;\n    return !(ready && newReady);\n  }\n\n  checkWidth(clientWidth) {\n    const {id, ready, fullWidth} = this.props;\n    if (ready) {\n      return;\n    }\n    const {onLineReady, addChars} = this.props;\n    const remaining = fullWidth - clientWidth;\n    if (remaining > 0) {\n      const {labelWidth, copies} = this.props;\n      const initial = copies < 1 || labelWidth < 1;\n      const final = labelWidth > 1 && remaining < labelWidth;\n      if (initial || final) {\n        addChars(1, clientWidth);\n      }\n      else {\n        addChars(Math.floor(remaining / labelWidth), clientWidth);\n      }\n    }\n    else {\n      onLineReady(id);\n    }\n  }\n\n  render() {\n    const {cls, stl} = this.props;\n    const {children} = this.props;\n    return (\n      <div style={stl} className={cls}\n        ref={(el) => {\n          if (el) {\n            this.checkWidth(el.clientWidth);\n          }\n        }}\n      >\n        {children}\n      </div>\n    );\n  }\n}\nexport default OutputLine;\n","import React, { Fragment, Component } from 'react';\n\nclass OutputChar extends Component {\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const oldChar = this.props.children;\n    const newChar = nextProps.children;\n    return oldChar !== newChar;\n  }\n\n  render() {\n    const {children} = this.props;\n    if (children === ' ') {\n      return (\n        <Fragment>&nbsp;</Fragment>\n      );\n    }\n    return children;\n  }\n}\nexport default OutputChar;\n","import React, { Component } from 'react';\nimport styles from './Output.module.css';\nimport OutputLine from './OutputLine';\nimport OutputChar from './OutputChar';\n\nconst makeNewLine = (line=[]) => {\n  return {\n    ready: false,\n    line: line,\n    copies: 0\n  }\n}\n\nconst isSameOffset = (v0, v1, label) => {\n  if ('offset' in v0 && 'offset' in v1) {\n    return v0.offset % label.length === v1.offset % label.length;\n  }\n  return false;\n}\n\nconst minFloor = (v0, v1) => {\n  return Math.floor(Math.min(v0, v1));\n}\n\nconst sameFloor = (v0, v1) => {\n  return Math.floor(v0) === Math.floor(v1);\n}\n\nclass Output extends Component {\n  constructor(props) {\n    super(props);\n    const SHAPE = [450, 950];\n    const {innerWidth, innerHeight} = window;\n    this.state = {\n      maxHeight: minFloor(SHAPE[1], innerHeight),\n      maxWidth: minFloor(SHAPE[0], innerWidth),\n      idealHeight: SHAPE[1],\n      idealWidth: SHAPE[0],\n      fontSize: 12,\n      lines: [makeNewLine()],\n      label: 'missingno',\n      labelWidth: 0\n    };\n    this.onLineReady = this.onLineReady.bind(this);\n    this.updateShape = this.updateShape.bind(this);\n    this.addChars = this.addChars.bind(this);\n  }\n\n  updateShape() {\n    const newState = {}\n    const {maxWidth, maxHeight} = this.state;\n    const {innerWidth, innerHeight} = window;\n\n    if (!sameFloor(maxWidth, innerWidth)) {\n      newState.maxWidth = Math.floor(innerWidth);\n    }\n    if (!sameFloor(maxHeight, innerHeight)) {\n      newState.maxHeight = Math.floor(innerHeight);\n    }\n    this.setState(newState);\n  }\n\n  getShape() {\n    const {idealWidth, idealHeight} = this.state;\n    const {maxWidth, maxHeight} = this.state;\n    return {\n      width: minFloor(idealWidth, maxWidth),\n      height: minFloor(idealHeight, maxHeight)\n    }\n  }\n\n  getMaxLines() {\n    const {fontSize} = this.state;\n    const {height} = this.getShape();\n    return Math.floor(height / fontSize);\n  }\n\n  isWholeLabel(line) {\n    const {label} = this.state;\n    const lastChar = line[line.length - 1];\n    return line.length > 1 && isSameOffset(line[0], lastChar, label);\n  }\n\n  newLine(line=[]) {\n    return makeNewLine(line);\n  }\n\n  newChar(offset, char=null) {\n    const {label} = this.state;\n    return {\n      char: char === null ? (label[offset % label.length]) : char,\n      offset: offset\n    }\n  }\n\n  getNextOffset(line, char=null) {\n    const lastIndex = line.length - 1;\n    const lastChar = line[lastIndex] || this.newChar(-1, null);\n    const offset = lastChar.offset + (char === null ? 1: 0);\n    return offset;\n  }\n\n  getLastLine(lines) {\n    const lastIndex = lines.length - 1;\n    return lines[lastIndex] || this.newLine();\n  }\n\n  addCharToLine(lineState, char=null) {\n    const {line, copies} = lineState;\n\n    const offset = this.getNextOffset(line, char);\n    const newChar = this.newChar(offset, char);\n    const newLine = line.concat([newChar]);\n\n    const finishedCopy = this.isWholeLabel(newLine);\n    const newCopies = copies + (finishedCopy? 1 : 0);\n\n    return {\n      ...lineState,\n      line: newLine,\n      copies: newCopies\n    };\n  }\n\n  addChars(num, clientWidth) {\n    const {lines} = this.state;\n    let missing = [\n      [0,0,0,0,0,0,0,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,0,0,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,1,1,1,1,1,0,0],\n      [0,0,0,0,0,0,0,0,0],\n    ];\n\n    const {width} = this.getShape();\n    const maxLines = this.getMaxLines();\n\n    const guessMask = (i) => {\n      const {label, labelWidth} = this.state;\n      const guessCharWidth = labelWidth / label.length;\n      const guessWidth = clientWidth + i * guessCharWidth;\n      const x = Math.floor((guessWidth / width) * missing[0].length);\n      const y = Math.floor(((lines.length - 1) / maxLines) * missing.length);\n      return missing[y][x];\n    }\n\n    const numRange = [...Array(num).keys()];\n    const {lastLine, labelWidth} = numRange.reduce((output, i) => {\n      const space = guessMask(i) === 1 ? ' ' : null;\n      const lastLine = this.addCharToLine(output.lastLine, space);\n      const labelWidth = output.labelWidth || (\n        lastLine.copies === 1 ? clientWidth : null\n      );\n      return {\n        labelWidth,\n        lastLine\n      };\n    }, {\n      labelWidth: this.state.labelWidth,\n      lastLine: this.getLastLine(lines)\n    });\n    const newLines = lines.slice(0,-1).concat([lastLine]);\n    this.setState({\n      lines: newLines,\n      labelWidth\n    })\n  }\n\n  addLines(num=1) {\n    if (num!==1) {\n      console.error('Cannot add multiple lines yet');\n      return;\n    }\n    const numRange = [...Array(num).keys()];\n    const {lines} = numRange.reduce((output) => {\n      // TODO... only works for num=1\n      const lastLine = this.getLastLine(output.lines)\n      const offset = this.getNextOffset(lastLine.line);\n\n      const newLines = output.lines.concat([\n        this.newLine([\n          this.newChar(offset, null)\n        ])\n      ]);\n      return {\n        lines: newLines\n      };\n    }, {\n      lines: this.state.lines\n    });\n    this.setState({\n      lines: lines\n    })\n  }\n\n  onLineReady(id) {\n    const {lines} = this.state;\n    if (id < lines.length) {\n      const newLines = lines.map((line, i) => {\n        if (id === i) {\n          return {\n            ...line,\n            ready: true\n          };\n        }\n        return line;\n      });\n      this.setState({\n        lines: newLines\n      });\n    }\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.updateShape);\n\n    this.timer = setInterval(() => {\n      const {lines} = this.state;\n      const maxLines = this.getMaxLines();\n      const {ready} = this.getLastLine(lines);\n      if (ready && lines.length < maxLines) {\n        this.addLines(1);\n      }\n    }, 100);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timer);\n  }\n\n  render() {\n    const {fontSize} = this.state;\n    const {lines, labelWidth} = this.state;\n    const {width, height} = this.getShape();\n\n    const outlineStyle = {\n      fontSize: `${fontSize}px`,\n    };\n    const centerStyle = {\n      'width': `${width}px`,\n      'height': `${height}px`\n    };\n\n    const outline = (\n      <div style={outlineStyle} className={styles.outline}>\n        {lines.map(({line, copies, ready}, i) => {\n          const lineStyle ={\n            top: i * fontSize\n          };\n          return (\n            <OutputLine addChars={this.addChars} onLineReady={this.onLineReady}\n              labelWidth={labelWidth} fullWidth={width}\n              copies={copies} ready={ready}\n              stl={lineStyle} cls={styles.line} key={i} id={i}\n            >\n              {line.map(({char}, j) => {\n                return (\n                  <OutputChar key={j}>\n                    {char}\n                  </OutputChar>\n                );\n              })}\n            </OutputLine>\n          );\n        })}\n      </div>\n    );\n    return (\n      <div className={styles.grid}>\n        <div></div>\n        <div style={centerStyle}>\n          {outline}\n        </div>\n        <div></div>\n      </div>\n    )\n  }\n}\nexport default Output;\n","import Output from './Output.js';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div>\n        Hello Missingno\n      </div>\n      <Output>\n      </Output>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './containers/App';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"outline\":\"Output_outline__30pg-\",\"line\":\"Output_line__3suFW\",\"grid\":\"Output_grid__2lwKT\"};"],"sourceRoot":""}